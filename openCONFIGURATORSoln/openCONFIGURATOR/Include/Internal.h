/**
 *****************************************************************************************************
 \file			Internal.h

 \brief			Handles function definitions and constant defintions used internally
 *****************************************************************************************************
 */

/*

 (c) Kalycito Infotech Private Limited

 License:

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:

 1. Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in the
 documentation and/or other materials provided with the distribution.

 3. Neither the name of Kalycito Infotech Private Limited nor the names of 
 its contributors may be used to endorse or promote products derived
 from this software without prior written permission. For written
 permission, please contact info@kalycito.com.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 POSSIBILITY OF SUCH DAMAGE.

 Severability Clause:

 If a provision of this License is or becomes illegal, invalid or
 unenforceable in any jurisdiction, that shall not affect:
 1. the validity or enforceability in that jurisdiction of any other
 provision of this License; or
 2. the validity or enforceability in other jurisdictions of that or
 any other provision of this License.

 ****************************************************************************/
#ifndef Internal_h
#define Internal_h

/****************************************************************************************************/
/* Includes */

#include <stddef.h>
#include <string>
#include <libxml/xmlwriter.h>
#include <libxml/xmlreader.h>
#include "Exports.h"
#include "Index.h"
#include "ProjectSettings.h"
#include "ProcessImage.h"
#include "Declarations.h"
#include "Node.h"
#include "IndexCollection.h"
#include "NetworkManagement.h"
#include "Exception.h"

/*************************************************************************************************/
/* Defines */

#define TOOL_VERSION "1.2.2"
#define LAST_TOOL_VERSION "1.2.1"
#define PREV_TOOL_VERSION_1 "1.1.0"
#define PREV_TOOL_VERSION_2 "1.0.1"
#define PREV_TOOL_VERSION_3 "1.0.0"
#define PREV_TOOL_VERSION_4 "1.1.1"
#define PREV_TOOL_VERSION_5 "1.1.2"
#define PREV_TOOL_VERSION_6 "1.2.0"
#define TOOL_INTER_REL_VERSION_1 "1.1.2.1"
#define TOOL_INTER_REL_VERSION_2 "1.1.2.2"
#define TOOL_INTER_REL_VERSION_3 "1.1.2.3"
#define TOOL_INTER_REL_VERSION_4 "1.1.2.4"
#define TOOL_INTER_REL_VERSION_5 "1.1.2.5"
#define ALLOC_BUFFER 5
#define INDEX_LEN 5
#define SUBINDEX_LEN 3
#define RANGE_INDEX 3
#define STR_ALLOC_BUFFER 1
#define MAX_PI_SIZE 4064
#define PROJECT_FILE_NAME 500
#define LINUX_INSTALL_DIR "/usr/share/openCONFIGURATOR-"TOOL_VERSION
#define LINUX_INSTALL_DIR_LEN 50
#define BUILD_COMMENT "This file was autogenerated by openCONFIGURATOR-"TOOL_VERSION" on "

#define INCLUDE_GUARD_CHECK "#ifndef XAP_h"
#define INCLUDE_GUARD_START "#define XAP_h"
#define INCLUDE_GUARD_END "#endif"

#define EPL_NODEASSIGN_NODE_EXISTS      0x00000001L // Bit 0
#define EPL_NODEASSIGN_NODE_IS_CN       0x00000002L // Bit 1
#define EPL_NODEASSIGN_START_CN         0x00000004L // Bit 2
#define EPL_NODEASSIGN_MANDATORY_CN     0x00000008L // Bit 3
#define EPL_NODEASSIGN_KEEPALIVE        0x00000010L //currently not used in EPL V2 standard
#define EPL_NODEASSIGN_SWVERSIONCHECK   0x00000020L // Bit 5
#define EPL_NODEASSIGN_SWUPDATE         0x00000040L // Bit 6
#define EPL_NODEASSIGN_ASYNCONLY_NODE   0x00000100L // Bit 8
#define EPL_NODEASSIGN_MULTIPLEXED_CN   0x00000200L // Bit 9
#define EPL_NODEASSIGN_RT1              0x00000400L // Bit 10
#define EPL_NODEASSIGN_RT2              0x00000800L // Bit 11
#define EPL_NODEASSIGN_MN_PRES          0x00001000L // Bit 12
#define EPL_NODEASSIGN_CHAINED_CN       0x00004000L // Bit 14
#define EPL_NODEASSIGN_VALID            0x80000000L // Bit 31
/************************************************************************************************/
/* Enumerations */

typedef enum
{
	ADD = 0, DELETE
} EOperation;

/************************************************************************************************/
/* structure */

#define BUILDTIME_BUF_LEN 80

typedef struct
{
		time_t rawtime;
		struct tm * timeinfo;
		char buffer[BUILDTIME_BUF_LEN];
} sBuildTime;

/************************************************************************************************/
/* Externs */

extern int iConfigDate;
extern int iConfigTime;
extern UINT32 uiCycleNumber;

/************************************************************************************************/
/* Global variables */

static const int g_simple_arr_size = 19;
static const UINT32 uiPreScalar = 0;

/****************************************************************************************************/
/* Function Declarations */

char* ConvertToUpper(char* str);
char* _IntToAscii(long value, char* result, INT32 base);
bool CheckIfNotPDO(char* Index);
bool CheckIfNotPDO(char* Index);
void ProcessUniqueIDRefs();
char* subString(char* str, INT32 startpos, INT32 len);
char* reverse(char* str);
ocfmRetCode ProcessPDONodes();
ocfmRetCode ProcessPDONodes(bool IsBuild);
ocfmRetCode GenerateMNOBD(bool IsBuild);
bool CheckIfManufactureSpecificObject(char* Index);
bool IsAscii(char c);
INT32 lenOfCNBuffer(char* Buffer);
char* padLeft(char* str, char padChar, INT32 padLength);
unsigned long hex2int(char *a);
CIndex* getMNIndexValues(char* Index);
bool CheckAllowedCNIndexes(char* IndexValue);
bool CheckBlockedMNIndexes(char* IndexValue);
//TODO: To be removed. Convert cdc to binary
INT32 ConvertCdcToBinary(char* fileName, char* tempFile);
char* getParameterAccess(char* access);
bool CheckEndElement(INT32 NodeType, char* element, char* comparewith);
bool CheckStartElement(INT32 NodeType, char* element, char* comparewith);
bool CheckifSimpleDT(char* Name, char* size);
char* getPIName(INT32 NodeID);
void setIndexAttributes(xmlTextReaderPtr reader, CIndex* objIndex,
		bool& hasPDO);
void setSubIndexAttributes(xmlTextReaderPtr reader, CSubIndex* objSubIndex);
void setDataTypeAttributes(xmlTextReaderPtr reader, DataType* objDataType);
char* ConvertToHexformat(char* hexValue, INT32 padlength, bool DoPadding);
INT32 getCNDataLen(char* Buffer);
bool CheckIfDataTypeExists(char* dtVal, INT32 NodeID);
bool CheckIfMappingPDO(char* Index);
bool CheckIfHex(char* value);
void WriteXAPElements(ProcessImage piCol[], xmlTextWriterPtr& writer,
		INT32 VarCount, EPIDirectionType piType);
void StartXAPxml(xmlTextWriterPtr& writer, xmlDocPtr& doc);
void EndWrtitingXAP(xmlTextWriterPtr& writer, char* fileName, xmlDocPtr& doc);
bool CheckIfSubIndexExists(INT32 NodeID, ENodeType NodeType, char* IndexID,
		char* SubIndexID);
ocfmRetCode processProjectXML(xmlTextReaderPtr reader, char* PjtPath);
bool IfVersionNumberMatches(xmlTextReaderPtr reader);
bool setProjectSettings_Auto(xmlTextReaderPtr reader);
bool setProjectSettings_Communication(xmlTextReaderPtr reader);
INT32 getConfigDate();
INT32 getConfigTime();
bool getandCreateNode(xmlTextReaderPtr reader, char* PjtPath);
bool saveProjectXML(char* ProjectPath, char* ProjectName);
void SetSIdxValue(char* Idx, char* SIdx, char* value,
		CIndexCollection * objIdxCol, INT32 NodeId, ENodeType NodeType,
		bool setDefaultValue);
ocfmRetCode AddOtherRequiredCNIndexes(INT32 NodeId);
void CreateMNPDOVar(INT32 Offset, INT32 dataSize, IEC_Datatype dtenum,
		EPDOType pdoType, CNode *objNode);
INT32 getNodeTotalIndexSubIndex(INT32 NodeID);
INT32 reversedata(UINT8 *actemp1, UINT8 *actemp2, UINT32 size);
char* StringToUpper(char* str);
void setFlagForRequiredCNIndexes(INT32 NodeId);
void UpdateCNCycleTime(CIndexCollection *objIdxCol, char* cycleTime);
void UpdateNumberOfEnteriesSIdx(CIndex *objIndex, ENodeType NodeType);
INT32 getDataSize(char* dataTypeVal);
bool checkIfStringDatatypes(char* datatypeValue);
bool CheckIfDataTypeByNameExists(char* dtName, INT32 iNodeID);
ocfmRetCode AddOtherMNIndexes(INT32 NodeID);
void AuotgenerateOtherIndexs(CNode* objNode);
void UpdatedCNDateORTime(CIndex* pobjMNIndex, INT32 iNodeId, EDateTime eDT);
void copyPDODefToAct(INT32 iNodeID, ENodeType enumNodeType);
void copyMNPropDefToAct(INT32 iNodeID, ENodeType enumNodeType);
void copySubIndexDefToAct(INT32 iNodeID, ENodeType enumNodeType, bool bForce,
		char *indexId, char *subIndexId);
void copyIndexDefToAct(INT32 iNodeID, ENodeType enumNodeType, char *indexId);
void setFlagForRequiredMNIndexes(INT32 iNodeId);
bool CheckAllowedDTForMapping(char* dtName);
void setFeatures(xmlTextReaderPtr reader, Feature* stFeature);
CIndex getPDOIndexByOffset(CIndex* objIndex);
char* setNodeAssigmentBits(CNode* objNode);
char* getLastAvailableCycleNumber();
ocfmRetCode RecalculateMultiplex();
void checkAndCorrectName(char* checkName);
void CheckAndReAssignMultiplex(INT32 iCNNodeId, char* CycleValue);
ocfmRetCode CheckMutliplexAssigned();
UINT32 getFreeCycleNumber(UINT32 uiCycleNumber);
bool IsMultiplexCycleNumberContinuous(UINT32 uiCycleNumber);
void calculateCNPollResponse(INT32 iNodeID, ENodeType enumNodeType);
ocfmRetCode CheckUpperAndLowerLimits(char* pcLowLimit, char* pcHighLimit);
ocfmRetCode AddSubobject(INT32 iNodeID, ENodeType enumNodeType,
		char* pbIndexID);
CSubIndex* getMNSubIndexValues(char* pbIndex, char* pbSubIndex);
void UpdateCNAsyncMTUsize(CIndexCollection *pobjIdxCol, char* pbAsyncMTUsize);
void UpdateCNMultiPrescal(CIndexCollection *pobjIdxCol, char* pbMultiPrescal);
bool checkIfValueZero(char* pcValue);
INT32 GetDecimalValue(char* pcValue);
void UpdateCNNodeAssignment(CNode* pobjNode);
void ResetMultiplexedCNForceCycle();
bool CheckIfMultiplexedCNExist();
void CopyCustomErrorString(ocfmRetCode* stRet, char* pcCustomErrString);
void UpdateCNMultipleCycleAssign(CNode* pobjNode);
void UpdateMNNodeAssignmentIndex(CNode *pobjNode, INT32 CNsCount, char* pcIndex,
		bool allowMNSubindex);
void RecalculateCNPresTimeout(char* pbSubIndexId);
bool ValidateCNPresTimeout(char* pbSubIndexId, char* pcCheckValue);
void CopyOldNodeIdAssignmentObject(CNode* pobjNode, INT32 iOldNodeId);
void CopyOldNodeIdAssignmentObjectSubindex(CNode* pobjNode, INT32 iOldNodeId,
		char* pcIndex);
bool CheckAccessTypeForInclude(char* pcAccesstype);
CSubIndex* DuplicateSubIndexObject(CSubIndex* pobjSubindex);
void EnableDisableMappingPDO(CIndexCollection* pobjIdxCol, CIndex* objIndex,
		char* Buffer, bool EnableFlag);
void FormatCdc(CIndexCollection *objIndexCollection, char* Buffer1,
		FILE* fileptr, ENodeType eNodeType);
bool IsDefaultActualNotEqual(CBaseIndex* pBaseIndexObject);
bool ReactivateMappingPDO(CIndexCollection* pobjIndexCol, CIndex* pobjIndex);
void BRSpecificFormatCdc(CIndexCollection *objIndexCollection, char* Buffer1,
		FILE* fileptr, ENodeType eNodeType, INT32 iNodeId);
void BRSpecificGetIndexData(CIndex* objIndex, char* Buffer, INT32 iNodeId);
INT32 BRSpecificgetCNsTotalIndexSubIndex(INT32 iNodeID);
void UpdateCNSoCTolerance(CIndexCollection *pobjIdxCol, char* pbSocTolerance);
INT32* ArrangeNodeIDbyStation();
void SortNodeID(INT32 *piNodeIDColl, INT32 iColSize);
bool IsPresMN();
void setPresMNNodeAssigmentBits();
bool CheckToolVersion(char* pcCurrentToolVersion);
void UpdatePreqActLoad(CNode* pobjNode, EAutoGenerate ePjtSetting);
void UpdatePresActLoad(CNode* pobjNode);
void UpdateCNPresMNActLoad(CNode* pobjNode);
void UpdateCNVisibleNode(CNode* pobjNode);
bool ISCNNodeAssignmentValid(CNode* pobjNode);
bool CopyMNSubindexToCN(CNode* pobjNode, char *pcIndex, char *pcSubIndex);
void CalculatePayload();
void SetCNLossObjects(INT32 iNodeID, ENodeType enumNodeType);
void ResetAllSubIndexFlag(CIndex *pobjIndex);
void ResetAllPdos(INT32 nodeId, ENodeType nodeType);
ocfmRetCode SetSubIndexAttributesByAttribute(INT32 iNodeID,
		ENodeType enumNodeType, char* pbIndexID, char* pbSubIndexID,
		EAttributeType enumAttributeType, char* pbInAttributeValue);
void SetBuildTime();
const char* GetBuildTime();

char* ConvertStringToHex(char* actString);

#endif // internal_h
